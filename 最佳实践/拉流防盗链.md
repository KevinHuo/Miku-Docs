播放防盗链可以有效避免直播资源被非法盗用的问题。使用播放防盗链前需要在域名配置中开启时间戳防盗链功能并设置防盗链 key。

在开启时间戳防盗链并使用防盗链地址访问七牛直播节点时，七牛直播节点会用同样的算法来计算访问链接是否合法，只有在合法时才返回所要访问的资源，否则快直播返回 500，flv / hls 返回 403。

# 防盗链地址生成方法

生成防盗链地址的方法是在播放域名上设置`时间戳防盗链 key`，并将经过计算得到的`加密字符串 sign` 和`访问过期时间 t` 拼接在相应域名的播放地址之后，生成完整的时间戳防盗链地址。

以HLS播放地址为例，开启了时间戳防盗链的播放地址格式如下：

```
http://<HLSPlayDomain>/<Hub>/<streamTitle>.m3u8?t=<ExpireAt>&sign=<Sign>
```

<!-- 各协议防盗链播放地址格式可见：

[RTMP播放地址](/pili/api/2768/rtmp-broadcast-address)

[HLS播放地址](/pili/api/2769/hls-broadcast-address)

[HDL(HTTP-FLV)播放地址](/pili/api/2770/hdl-http-flv-broadcast-address) -->



**具体生成方法如下：**

## 开启时间戳防盗链并获取防盗链key

- 登录控制台，进入目标直播空间的域名管理页面
- 点击相应播放域名的管理按钮，进入域名配置页面，开启时间戳防盗链配置开关，并设置主密钥和副秘钥。

## 确定过期时间

生成的时间戳防盗链播放地址在过期时间前有效，可以正常访问，在过期时间后失效。防盗链地址中的 t 即为过期时间的unix时间戳。

```bash
t = date -j -f "%Y-%m-%d %H:%M:%S" '2025-10-29 20:00:00' +%s
```

其unix时间戳为 1761739200


## 计算加密字符串 sign

计算 sign 需要前面设置的防盗链 key、访问地址中的 path 部分和过期时间 t，计算方法为：

```bash
sign=md5(key+path+t).to_lower()
```

`sign` 中的字母需要小写。

# 示例

若一个未开启时间戳防盗链的HLS播放地址为

```bash
http://pili-hls.pilitest.com/testHub/testStream.m3u8
```

在开启时间戳防盗链后，设置的防盗链 key 为 test。

若需要生成过期时间为 2025-10-29 20:00:00（UNIX时间戳为 1761739200）的防盗链地址，则

```
key=test
path=/testHub/testStream.m3u8
t=1761739200
```

所以

```
sign=md5(key+path+t).to_lower()=md5(test/testHub/testStream.m3u81761739200).to_lower()=e85ab37318c95e8871dcbdc892b8af90
```

将 `sign` 和 `t` 拼接在未开启时间戳防盗链的HLS播放地址之后，得到最终的防盗链播放地址：

```
http://pili-hls.pilitest.com/testHub/testStream.m3u8?sign=e85ab37318c95e8871dcbdc892b8af90&t=1761739200
```

# 示例代码

```java
package com.qiniu.hugo.miku;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class miku_timestampAntiLeechUrl {
    private static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    public static void main(String[] args) {
        getTimestampAntiLeechUrl();
    }

    /**
     * 构建时间戳防盗链访问链接
     */
    public static void getTimestampAntiLeechUrl() {
        String url = "rtmp://xxx";
        // 链接过期时间
        long deadline = System.currentTimeMillis() / 1000 + 720000;
        // 签名密钥，从后台域名的推流鉴权获取
        String encryptKey1 = "xxx";
        String signedUrl;
        try {
            signedUrl = createTimestampAntiLeechUrl(url, encryptKey1, deadline);
            System.out.println(signedUrl);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static String createTimestampAntiLeechUrl(String url, String encryptKey, long deadline) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        String path = url.substring(url.indexOf("/", url.indexOf("//") + 2));
        String urlencodedPath = URLEncoder.encode(path, "UTF-8").replaceAll("%2F", "/");
        String expireHex = String.valueOf(deadline); // unix_time 10位
        String toSignStr = String.format("%s%s%s", encryptKey, urlencodedPath, expireHex);
        String signedStr = md5Lower(toSignStr);
        String signedUrl = String.format("%s?sign=%s&t=%s", url, signedStr, expireHex);

        return signedUrl;
    }

    public static String md5Lower(String src) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance("MD5");
        digest.update(src.getBytes(Charset.forName("UTF-8")));
        byte[] md5Bytes = digest.digest();
        return encodeHexString(md5Bytes);
    }

    private static String encodeHexString(byte[] data) {
        return new String(encodeHex(data));
    }

    private static char[] encodeHex(byte[] data) {
        return encodeHex(data, true);
    }

    private static char[] encodeHex(byte[] data, boolean toLowerCase) {
        return encodeHex(data, DIGITS_LOWER);
    }

    private static char[] encodeHex(byte[] data, char[] toDigits) {
        int l = data.length;
        char[] out = new char[l << 1];

        for (int i = 0, j = 0; i < l; i++) {
            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];
            out[j++] = toDigits[0x0F & data[i]];
        }

        return out;
    }
}
```

```go
package main

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"net/url"
	"strings"
	"time"
)

func main() {
	getTimestampAntiLeechUrl()
}

// getTimestampAntiLeechUrl prints the timestamp anti-leech URL
func getTimestampAntiLeechUrl() {
	url := "rtmp://xxxx/xxxx"
	// 链接过期时间
	deadline := time.Now().Unix() + 720000
	// 签名密钥，从后台域名的推流鉴权获取
	encryptKey1 := "xxxxxxx"
	signedUrl, err := createTimestampAntiLeechUrl(url, encryptKey1, deadline)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println(signedUrl)
}

func createTimestampAntiLeechUrl(baseUrl, encryptKey string, deadline int64) (string, error) {
	u, err := url.Parse(baseUrl)
	if err != nil {
		return "", err
	}
	path := u.Path
	urlencodedPath := strings.ReplaceAll(url.QueryEscape(path), "%2F", "/")
	expireHex := fmt.Sprintf("%d", deadline) // unix_time 10位
	toSignStr := fmt.Sprintf("%s%s%s", encryptKey, urlencodedPath, expireHex)
	signedStr := md5Lower(toSignStr)
	signedUrl := fmt.Sprintf("%s?sign=%s&t=%s", baseUrl, signedStr, expireHex)

	return signedUrl, nil
}

func md5Lower(src string) string {
	hash := md5.Sum([]byte(src))
	return hex.EncodeToString(hash[:])
}

```