七牛直播推流主要的鉴权方式有"无校验鉴权", "限时鉴权"。


# 无校验鉴权(none)
> **风险**： 如果没有鉴权，直播空间存在被盗用的风险

推流地址格式：
```
rtmp://<RTMPPublishDomain>/<Hub>/<streamTitle>
```
* RTMPPublishDomain - 推流域名
* Hub - 直播空间名称
* streamTitle - 直播流名称

示例：
```
RTMPPublishDomain: test.miku.com
Hub: sdk-live
streamTitle: test
```

推流地址:
```
rtmp://test.miku.com/sdk-live/test
```

# 限时鉴权(expiry)

使用限时鉴权的方法是在播放域名上设置`推流鉴权 key 密钥`，并将经过计算得到的`加密字符串 sign` 和`访问过期时间 t` 拼接在相应域名的播放地址之后，生成完整的限时鉴权推流地址。

以 RTMP 推流地址为例，开启了限时鉴权的推流地址格式如下： 
```
rtmp://test.miku.com/sdk-live/test
```

在开启限时后，设置的推流密钥为 test。

**具体生成方法如下：**

* PublishKey - 推流密钥
* RTMPPublishDomain - 推流域名
* Hub - 直播空间名称
* streamTitle - 直播流名称
* ExpireAt - UNIX Timestamp。时间的单位精确到秒， 预计推流动作发生的时间。举例说明，当前时刻为12:00，预计12:20之前推流，超过时间后不可推流。将此刻12:20换算为UNIX Timestamp。
```bash
t = date -j -f "%Y-%m-%d %H:%M:%S" '2025-08-25 20:00:00' +%s
```
* Sign - 是经过 md5 计算生成的

```bash
sign = md5(publishKey+path+t).to_lower() 
```
publishKey：推流密钥，可以在 miku portal 空间或者推流域名中设置
path：地址，例如推流地址为 rtmp://test.miku.com/sdk-live/test，那么 path 则为 /sdk-live/test
t：上面所生成的 UNIX Timestamp

> protal 中主、副密钥都可以用于鉴权效果一致，副密钥用于防止主密钥失效后备用

示例：
```
RTMPPublishDomain: test.miku.com
Hub: sdk-live
streamTitle: test
ExpireAt: 1756110618
PublishKey: test

SignStr = "test/sdk-live/test1756110618"
sign = md5(SignStr).to_lower() = 6a1b665f529c8b57d6408b72e4d21350
```

推流地址:
```
rtmp://test.miku.com/sdk-live/test?sign=6a1b665f529c8b57d6408b72e4d21350&t=1756110618
```

# 示例代码

```java
package com.qiniu.hugo.miku;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class miku_timestampAntiLeechUrl {
    private static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    public static void main(String[] args) {
        getTimestampAntiLeechUrl();
    }

    /**
     * 构建时间戳防盗链访问链接
     */
    public static void getTimestampAntiLeechUrl() {
        String url = "rtmp://xxx";
        // 链接过期时间
        long deadline = System.currentTimeMillis() / 1000 + 720000;
        // 签名密钥，从后台域名的推流鉴权获取
        String encryptKey1 = "xxx";
        String signedUrl;
        try {
            signedUrl = createTimestampAntiLeechUrl(url, encryptKey1, deadline);
            System.out.println(signedUrl);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static String createTimestampAntiLeechUrl(String url, String encryptKey, long deadline) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        String path = url.substring(url.indexOf("/", url.indexOf("//") + 2));
        String urlencodedPath = URLEncoder.encode(path, "UTF-8").replaceAll("%2F", "/");
        String expireHex = String.valueOf(deadline); // unix_time 10位
        String toSignStr = String.format("%s%s%s", encryptKey, urlencodedPath, expireHex);
        String signedStr = md5Lower(toSignStr);
        String signedUrl = String.format("%s?sign=%s&t=%s", url, signedStr, expireHex);

        return signedUrl;
    }

    public static String md5Lower(String src) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance("MD5");
        digest.update(src.getBytes(Charset.forName("UTF-8")));
        byte[] md5Bytes = digest.digest();
        return encodeHexString(md5Bytes);
    }

    private static String encodeHexString(byte[] data) {
        return new String(encodeHex(data));
    }

    private static char[] encodeHex(byte[] data) {
        return encodeHex(data, true);
    }

    private static char[] encodeHex(byte[] data, boolean toLowerCase) {
        return encodeHex(data, DIGITS_LOWER);
    }

    private static char[] encodeHex(byte[] data, char[] toDigits) {
        int l = data.length;
        char[] out = new char[l << 1];

        for (int i = 0, j = 0; i < l; i++) {
            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];
            out[j++] = toDigits[0x0F & data[i]];
        }

        return out;
    }
}
```

```go
package main

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"net/url"
	"strings"
	"time"
)

func main() {
	getTimestampAntiLeechUrl()
}

// getTimestampAntiLeechUrl prints the timestamp anti-leech URL
func getTimestampAntiLeechUrl() {
	url := "rtmp://xxxx/xxxx"
	// 链接过期时间
	deadline := time.Now().Unix() + 720000
	// 签名密钥，从后台域名的推流鉴权获取
	encryptKey1 := "xxxxxxx"
	signedUrl, err := createTimestampAntiLeechUrl(url, encryptKey1, deadline)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println(signedUrl)
}

func createTimestampAntiLeechUrl(baseUrl, encryptKey string, deadline int64) (string, error) {
	u, err := url.Parse(baseUrl)
	if err != nil {
		return "", err
	}
	path := u.Path
	urlencodedPath := strings.ReplaceAll(url.QueryEscape(path), "%2F", "/")
	expireHex := fmt.Sprintf("%d", deadline) // unix_time 10位
	toSignStr := fmt.Sprintf("%s%s%s", encryptKey, urlencodedPath, expireHex)
	signedStr := md5Lower(toSignStr)
	signedUrl := fmt.Sprintf("%s?sign=%s&t=%s", baseUrl, signedStr, expireHex)

	return signedUrl, nil
}

func md5Lower(src string) string {
	hash := md5.Sum([]byte(src))
	return hex.EncodeToString(hash[:])
}

```